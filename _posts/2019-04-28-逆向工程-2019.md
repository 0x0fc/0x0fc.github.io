---
layout:     post
title:      逆向工程浅谈
subtitle:   逆向小序
date:       2019-04-28
author:     By Oxof
header-img: img/zhelong.jpg
catalog:    true
tags:
    - 逆向工程
---


##hey
>Day01  进制01    2019-04-19    ->2015-01-12
1.进制定义：N进制由N个符号组成，逢N进一  

2.十六进制转二进制  
      0          1          2          3         4          5          6         7                
   0000    0001    0010    0011    0100    0101   0110   0111   
      8          9          A          B         C         D          E        F    
   1000    1001    1010    1011    1100    1101   1110   1111

3.八进制加法表
   1+1=2
   1+2=3      2+2=4    
   1+3=4      2+3=5      3+3=6
   1+4=5      2+4=6      3+4=7       4+4=10
   1+5=6      2+5=7      3+5=10     4+5=11     5+5=12
   1+6=7      2+6=10    3+6=11     4+6=12     5+6=13      6+6=14
   1+7=10    2+7=11    3+7=12     4+7=13     5+7=14      6+7=15       7+7=16

  八进制乘法表
   1*1=1
   1*2=2     2*2=4    
   1*3=3     2*3=6     3*3=11
   1*4=4    2*4=10    3*4=14     4*4=20
   1*5=5    2*5=12    3*5=17     4*5=24     5*5=31
   1*6=6    2*6=14    3*6=22     4*6=30     5*6=36        6*6=44
   1*7=7    2*7=16    3*7=25     4*7=34     5*7=43        6*7=52        7*7=61
作业
1. 2+3=1是否成立
    答：成立   进制定义为自定义符号   

2. 二进制数用十六进制表示
  1100  1011  0101  0100  1110  1011  0101  0111  1011  0100  1010  1011
   C        B       5       6      C       B      5       7      9       4       A      B

3. 用二进制表示下列数字
       4        8        7          F        D        C       1        2        0         A       C        E       6         9        B       9        5        3         F       E
    0100  1000   0011   1111  1101   1100  0001  0010  0000  1010  1100  1110  0110  1001  1011  1001  0101  0011  1111  1110

4. 二进制0写到100   每行十个
  000000   000001   000010   000011   000100   000101   000110   000111   001000   001001  
  001010   001011   001100   001101   001110   001111   010000   010001   010010   010011
  010100   010101   010110   010111   011000   011001   011010   011011   011100   011101
  011110   011111   100000   100001   100010   100011   100100   100101   100110   100111

5.编写16进制加/乘法表



>Day02  进制02      2019-04-20    ->2015-01-13

//全部理解,无需笔记



>Day03  数据宽度_逻辑运算   2019-04-21    ->2015-01-14

1.正数二进制0开头0-7为0000-0111,负数1开头8-F为1000-1111

2.常用计量单位  1byte(字节) = 8bit(位) , 1word(字) = 2byte , 1dword(双字) = 4byte

3.逻辑运算符
        ID     汇编    C语言       用法
  (1).  或      or        |      一个为1就是1
  (2).  与     and      &     两边为1才是1
  (3).  异或   xor      ^     不一样时为1
  (4).  非     not       !      取反,0为1,1为0、

4.CPU计算本质
  加法: 2+3
    X:0010      (1)->  0010   (2)->  0010    (3)->                 (4)->  0100(R3)    (5)->  0100
    Y:0011           xor 0011         & 0011    R2<<1 0010         xor 0001(R1)           & 0001
-----------------------------------------------------------------------------------------
                          R1  0001       R2  0010          R3  0100         R4  0101               R5  0000
                                 判断是否进位    左移一位                    都为0无进位，结果为R4

5.32位通用寄存器
  寄 存 器                    用   途                              编 号                  范 围       
    EAX                       累加器                                 0             0 - 0xFFFFFFFF
    ECX                        计  数                                 1       
    EDX                      I/O指针                                2      
    EBX                DS段的数据指针                         3       
    ESP                      堆栈 指针 /栈顶                     4       
    EBP                SS段的数据指针/栈底                  5      
    ESI          字符串操作源指针 SS段数据指针         6
    EDI         字符串操作目标指针 ES段数据指针      7

6.其他寄存器
    EIP         当前程序运行位置

7.汇编指令
  指 令             用      途
   MOV            移动/赋值寄存器

作业
1.练习5+7
    X:0101      (1)->  0101   (2)->  0101   (3)->               (4)->  1010(R3)    (5)->  1010                          1000            1000
    Y:0111           xor 0111         & 0111    R2<<1 0101     xor  0010(R1)          & 0010    <<0010    xor 0100    and 0100
-------------------------------------------------------------------------------------------------------------------------------------
                          R1  0010       R2  0101          R3  1010      R4  1000              R5  0010         0100          1110           0000        //5+7=0101+0111=1110=C
 
2.获取5E中右数第三位值是多少  提示and
0101  1110
0000  0100
--------------------
0000  0100    //第三位为1

3.简单加密2017   密钥38   提示xor
  加密:   0001 0111     解密:  0010 1111
            0011 1000               0011 1000
----------------------------------------------
            0010 1111               0001 0111

4.OD打开程序并观察程序运行



>Day04  通用寄存器_内存读写   2019-04-22    ->2015-01-15
1.32     16      8   位通用寄存器
  EAX    AX    AH    高八位
  ECX    CX    CH
  EDX    DX    DH
  EBX    BX     BH
  ESP    SP     AL    低八位
  EBP    BP     CL
  ESI     SI      DL
  EDI     DI     BL

2.MOV语法    拷贝源操作数到目标操作数
  r通用寄存器    m内存    imm立即数
  1.MOV r/m8     ,r8            源操作数可以是立即数,通用寄存器,段寄存器或内存单元
  2.MOV r/m16   ,r16          目标操作数可以是通用寄存器,段寄存器或内存单元
  3.MOV r/m32   ,r32          操作数宽度必须一致
  4.MOV r8         ,r/m8        源操作数和目标操作数不能同时为内存单元
  5.MOV r16       ,r/m16
  6.MOV r32       ,r/m32
  7.MOV r8         ,imm8
  8.MOV r16       ,imm16
  9.MOV r32       ,imm32

3.sub减法    add加法    and与    or或    xor异或    not非

4.内存格式
  1.[id]称为地址
  2.地址作用:向内存写入或读取数据
  3.写入格式
    mov word ptr ds:[0x0012FF34],0xFFFF     

作业
1.汇编指令全部练习一遍
    1.mov
    2.sub
    3.add
    4.and
    5.xor
    6.not



Day05  内存地址_堆栈   2019-04-23   ->2015-01-16
1.数据内存中存储时高位在后低位在前
    例如：反汇编0012FFDC ->B6B37CE4       内存中会存储为0012FFDC -> E4 7C B3 B6

2.八种寻址公式


1.寻址公式一：
[立即数]
2.寻址公式二：[ reg ]     
reg代表寄存器
3.寻址公式三：
[ reg + 立即数 ]
4.寻址公式四：
[ reg + reg * {1,2,4,8}]
读取内存数据       
mov eax , dword ptr ds : [ 0x13FFC4 ] 
读取内存数据
mov eax , 0x13FFD0 
mov ecx,dowrd ptr ds:[ eax ]
读取内存数据
mov eax , 0x13FFD0 
mov ecx,dowrd ptr ds:[ eax + 4 ]
读取内存数据
mov eax,13FFC4
mov ecx,2
mov edx , dword ptr ds:[eax+ecx*2]
向内存写数据                      
mov dword ptr ds:[ 0x13FFC4 ] , eax 
向内存写数据
mov eax , 0x13FFD0
mov dword ptr ds:[ edx ] , 0x45214567
向内存写数据
mov eax , 0x13FFD0
mov dword ptr ds:[ edx + 4] , 0x45214567
向内存写数据
mov eax,13FFC4
mov ecx,2
mov dowrd ptr ds:[eax+ecx*4],87456321
lea获取内存编号     
// 取0x13FFC4   而不是0x13FFC4的值          
lea eax , dword ptr ds:[0x13FFC4]
lea获取内存编号
lea eax , dword ptr ds : [ edx ]
mov eax , dword ptr ds : [ edx ]
lea获取内存编号
lea eax , dword ptr ds:[ edx +4 ]
mov eax , dword ptr ds:[ edx +4 ]
lea获取内存编号
lea eax,dowrd ptr ds:[eax+ecx84]


5.寻址公式五：
[ reg + reg * {1,2,4,8} + 立即数]
6.寻址公式六：[立即数]
7.寻址公式七：[立即数]
8.寻址公式八：[立即数]
读取内存数据 
mov eax,13ffc4
mov ecx,2
mov edx,dowrd ptr ds[eax+ecx*4+4]
读取内存数据 
读取内存数据 
读取内存数据 
向内存写数据
mov eax,13ffc4
mov ecx,2
mov dowrd ptr ds[eax+ecx*4+4],87654321
向内存写数据
向内存写数据
向内存写数据
lea获取内存编号
lea eax,dowrd ptr ds:[eax+ecx*4+2]
lea获取内存编号
lea获取内存编号
lea获取内存编号

3.堆栈概念
                   TOP   :0x100c      栈顶       小值+

                   BASE : 0x1000     栈底        大值-

2.例子
        1.先存值后提升栈顶
            mov ebx,12ffe0    ->栈底
            mov edx,12ffe0    ->栈顶    指向同一地址说明是空堆栈
            mov dword ptr ds:[edx-4],0xAAAAAAAA    ->把值存入堆栈中(存到edx-4内)
            sub edx,4        ->提升栈顶值 
        2.先提升栈顶后存值
            mov ebx,12ffe0        ->栈底
            mov edx,12ffe0
            lea edx,dword ptr ds:[edx-4]
            mov dowrd ptr ds:[edx],0x12345678

3.四种方式        ->压栈
        1.
            mov dword ptr ds:[edx-4],0xaaaaaaaa
            sub edx,4
        2.
            sub edx,4
            mov dword ptr ds:[edx],0xbbbbbbbb
        3.
            mov dword ptr ds:[edx-4],0xcccccccc
            lea edx,dowrd ptr ds:[edx-4]
        4.
            lea edx,dowrd ptr ds:[edx-4]
            mov dowrd ptr ds:[edx],0xdddddddd

4.堆栈找值
        mov esi,dword ptr ds:[ebx-8]        ->栈底+偏移取值
        mov dei,dword ptr ds:[edx+4]      ->栈顶+偏移取值    

5.取栈
        1.
            mov eax,dword ptr ds:[edx]
            add edx,4 
        2.
            lea edx.dword ptr ds:[edx+4]
            mov eax,dword ptr ds:[edx-4]
        3.
            mov ecx,dword ptr ds:[edx]
            lea edx,dword ptr ds:[edx+4]

6.push
        1.push相当于任意一种压栈方式，自动提升栈顶        push支持imm，r16/32，m16/32 . 当push imm，r16/32时push每次-4，
push m16/32值根据数据宽度进行减法，例如push word ptr ds:[0x12ffc4] 宽度为16位此时就-2。寄存器及内存均不支持8位
        2.pop 相当于任意一种弹栈方式，自动降低栈顶        pop支持r16/32，m16/32，pop r16/32时+4, popm16/32时根据数据宽度调整
        3.pop/pushad时会把通用寄存器全部pop/push到堆栈中(注意中间无空格，不是push寄存器)   例如popad   pushad        术语为堆栈平衡




    7.作业
        








